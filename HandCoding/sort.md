# 정렬

## 퀵 정렬

> 퀵 정렬은 분할정복(Divide and Conquer)을 기반으로 한 정렬 알고리즘이다.

- 배열에서 하나의 `피벗` 요소를 선택한다.
- 피벗보다 작은 요소들은 모두 피벗의 왼쪽으로, 큰 요소들은 오른쪽으로 옮깁니다.
- 이렇게 하면 피벗은 최종 위치에 오게되고, 피벗을 중심으로 배열이 두 부분으로 나뉜다.
- 이제 왼쪽 부분과 오른쪽 부분에서 각각 동일한 방식으로 퀵 정렬을 재귀적으로 적용한다.

> 퀵 정렬은 평균적으로 `O(N*logN)`으로 매우 빠른 성능을 보이지만, 최악의 경우 시간복잡도는 O(n^2)이 될 수 있습니다.

```
함수 퀵정렬(배열, 시작, 끝):
    만약 시작 < 끝:
        피벗 = 분할(배열, 시작, 끝)
        퀵정렬(배열, 시작, 피벗 - 1)
        퀵정렬(배열, 피벗 + 1, 끝)

함수 분할(배열, 시작, 끝):
    피벗값 = 배열[끝]
    i = 시작 - 1
    for j = 시작 to 끝 - 1:
        만약 배열[j] <= 피벗값:
            i = i + 1
            배열[i]와 배열[j] 교환
    배열[i + 1]과 배열[끝] 교환
    return i + 1

```

## 병합 정렬 (Merge Sort)

> 병합 정렬은 분할 정복(Divide and Conquer) 방식을 사용하는 정렬알고리즘이다.

- 배열을 반으로 계속 나누어 각 부분을 최소 단위(보통 1개 요소)까지 분할한다.
- 이후, 분할된 배열을 재귀적으로 다시 병합하면서 정렬한다.
- 병합 과정에서 두 부분 배열의 요소들을 비교하여 순서대로 새 배열에 삽입한다.

> 병합 정렬은 안정적인 정렬 방법이며, 시간 복잡도는 항상 `O(n log n)`이다. 그러나 추가 적인 메모리 공간을 필요로 한다.

```
함수 병합정렬(배열):
    만약 배열 길이 > 1:
        중간 = 배열 길이 / 2
        왼쪽 = 배열[:중간]
        오른쪽 = 배열[중간:]

        병합정렬(왼쪽)
        병합정렬(오른쪽)

        i = j = k = 0

        while i < len(왼쪽) and j < len(오른쪽):
            if 왼쪽[i] < 오른쪽[j]:
                배열[k] = 왼쪽[i]
                i = i + 1
            else:
                배열[k] = 오른쪽[j]
                j = j + 1
            k = k + 1

        while i < len(왼쪽):
            배열[k] = 왼쪽[i]
            i = i + 1
            k = k + 1

        while j < len(오른쪽):
            배열[k] = 오른쪽[j]
            j = j + 1
            k = k + 1

```

## 버블 정렬 (Bubble Sort)

> 버블 정렬은 가장 간단하고 직관적인 정렬 알고리즘 중 하나이다.

- 배열을 순차적으로 탐색하면서 인접한 요소들을 비교한다.
- 만약 순서가 잘못되어 있다면, 인접한 요소들의 위치를 서로 바꿉니다.
- 이 과정을 배열을 모든 요소가 올바른 순서에 올 때까지 반복한다.
  > 버블 정렬은 구현이 매우 간단하지만, 효율성이 낮아 큰 데이터 집합에는 부적합합니다. 평균 및 최악의 시간 복잡도는 `O(n^2)`

```
함수 버블정렬(배열):
    n = 배열 길이
    for i = 0 to n - 1:
        for j = 0 to n - i - 1:
            만약 배열[j] > 배열[j + 1]:
                배열[j]와 배열[j + 1] 교환

```

[처음으로](../README.md)
