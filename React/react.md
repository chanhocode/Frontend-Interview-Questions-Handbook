# React 정리

- [React의 개념](#react의-개념)
- [JSX](#jsx)
- [컴포넌트](#컴포넌트)
- [Vue 프레임워크와의 차이점은?](#vue-프레임워크와의-차이점은)
- [리액트 에서 상태(state)와 속성(props)의 차이](#리액트-에서-상태state와-속성props의-차이)
- [React의 LifeCycle](#react의-lifecycle)
- [리액트의 렌더링 동작 방식](#리액트의-렌더링-동작-방식)
- [Dom과 Virtual Dom의 차이점은?](#dom과-virtual-dom의-차이점은)
- [리액트에서 리스트를 렌더링할 때 '키'의 역할](#리액트에서-리스트를-렌더링할-때-키의-역할)
- [리액트의 훅을 사용하는 이유와 자주사용하는 훅은 무엇인가](#리액트의-훅을-사용하는-이유와-자주사용하는-훅은-무엇인가)
- [HOC(고차 컴포넌트)](#hoc고차-컴포넌트)

---

## React의 개념

> 리액트는 사용자 인터페이스를 구축하기 위한 자바스크립트 `라이브러리` 이다. 선언적인 뷰를 만 들 수 있어 코드의 가독성이 높고, 컴포넌트 기반으로 재사용 가능한 UI를 만들 수 있기 때문에 개발 효율성이 높아진다. 주로 `Single Page Application`을 만들 때 사용되며 가상 돔을 활용한 성능향상 및 클라이언트 사이드 렌더링을 지원한다. `리액트는 컴포넌트에 기반한 접근 방식을 사용하므로, 재사용 가능성이 높은 컴포넌트를 개발할 수 있다.`

### 주요 특징

> 리액트의 주요 특징으로는 `가상 DOM 사용, 컴포넌트 기반 구조, JSX 문법 사용, 단방향 데이터 흐름` 등이 있다. 이러한 특징들이 애플리케이션의 `성능을 향상 시키고 유지 보수를 용이`하게 한다.

- 가상 DOM: Real DOM의 in-memory 표현으로 UI표현은 메모리에 저장되며 Real DOM과 동기화 된다.
- 단방향 데이터 바인딩: HTML에 바인딩한 데이터를 Javascript에서 수정할 경우 화면에 반영되지만, 화면에서 직접 해당 엘리먼트의 값을 바꿨을 때는 Javascript의 데이터가 수정되는 방법은 제공하지 않는다.

---

## JSX

> JavaScript XML의 약자로, 자바스크립트 문법의 확장으로 `HTML 요소에 유효한 자바스크립트 객체를 내장 할 수 있는 자바스크립트의 확장이다.` JSX는 Javascript의 모든 기능이 포함되어 있고, `React Element를 생성하기 위해 사용`된다. 브라우저는 JSX을 직접 읽을 수 없으며, 바벨과 같은 컴파일러를 통해 변환한 파일을 브라우저가 읽는다.

---

## 컴포넌트

> 리액트에서 컴포넌트는 `UI를 구성하는 기본 단위로, 재사용 가능한 코드 블록이다.` 리액트 애플리케이션은 여러 개의 컴포넌트가 조합되어 만들어진다. 각 컴포넌트는 독립적이며, 자체적인 로직과 렌더링을 수행한다.

### 특징

- `재사용성`: 컴포넌트는 재사용이 가능하게 설계되어 있으며, 이를 통해 `코드의 중복을 줄이고 효율성`을 높일 수 있다.
- `독립성`: 각 컴포넌트는 독립적으로 작동하며, 다른 컴포넌트와의 상호작용은 `props(속성)`를 통해 이루어진다.
- `상태 관리`: 컴포넌트는 `자체적인 상태(state)`를 가질 수 있으며, 이 상태에 따라 UI를 업데이트 할 수 있습니다.
- `생명주기`: 컴포넌트는 `생성, 업데이트, 소멸`의 생명주기를 가지며, 각 단계에서 특정한 작업을 수행할 수 있습니다.

### 종류

- 클래스 컴포넌트: ES6 클래스를 사용하여 생성되며, 상태와 생명 주기 메서드를 사용할 수 있습니다.
- 함수형 컴포넌트: ES6 함수로 작성되며, 상태가 없고 생명주기 메서드를 사용할 수 없었으나, React Hooks의 도입으로 이러한 제한이 해소되었다.

### 컴포넌트 사용시

> 컴포넌트를 사용하면 리액트에서 UI를 구성할 때, 일반적으로는 작고 `단일 기능을 하는 컴포넌트를 만들어 조합`하는 방식을 추구한다. 이렇게 함으로써 각 컴포넌트의 `관리가 용이`해지고, 전체 애플리케이션의 `유지보수가 쉬워`진다.

### 컴포넌트 나누는 기준(디자인 패턴)

- `단일 책임 원칙`

  > `각 컴포넌트는 하나의 기능만을 담당`해야 합니다. 이는 컴포넌트가 너무 많은일을 하지 않도록 하며, 재사용성과 유지보수가 용이하게 합니다.

- `재사용성`

  > `비슷한 기능이나 UI를 가진 부분들은 재사용 가능한 컴포넌트로 분리`해야 합니다. 이렇게 함으로써 코드 중복을 줄이고, 일관된 UI/UX를 유지할 수 있습니다.

- `컴포넌트의 크기`

  > 너무 크거나 복잡한 컴포넌트는 유지보수와 이해하기 어렵습니다. 컴포넌트를 작고 관리하기 쉬운 단위로 분리하는 것이 좋습니다.

- `컴포지션`

  > 컴포넌트들을 조합하여 더 큰 기능을 구성할 수 있습니다. 이는 '컴포넌트 안에 컴포넌트를 넣는 것'을 의미하며, 복잡한 UI를 간결하고 모듈식으로 구성할 수 있게 해줍니다.

- `특화된 컴포넌트`

  > 특정한 목적이나 기능을 위한 컴포넌트를 만들어 사용합니다. 예를 들어, 폼 입력 처리, 리스트 렌더링 등 특정 작업을 위한 컴포넌트를 분리하여 사용할 수 있습니다.

- `컨테이너와 프레젠테이션 컴포넌트`

  > 데이터 처리와 관련된 로직은 컨테이너 컴포넌트에서 처리하고, UI 렌더링은 프레젠테이션 컴포넌트에서 처리합니다. 이는 관심사의 분리를 촉진시키며, 각각의 컴포넌트가 자신의 역할에 집중할 수 있도록 합니다.

---

## Vue 프레임워크와의 차이점은?

> 먼저, `리액트는 자바스크립트 라이브러리`로, 사용자 인터페이스를 만드는 대 집중한다. "가상 DOM"과 "재사용 가능한 컴포넌트"를 핵심 개념으로 사용한다. `뷰는 점진적 프레임워크`로, 쉽게 통합되고 확장 될수 있는 구조를 가지고 있다. HTML 기반의 템플릿 문법과 반응형 데이터 바인딩을 중요한 특징으로 삼는다. 데이터 바인딩에도 차이점을 가지는대, `리액트는 단방향 데이터 바인딩`을 사용한다. 상태가 변경되면 해당 상태를 사용하는 컴포넌트가 재렌더링 된다. `뷰는 양방향 데이터 바인딩`을 지원한다. 이는 폼 입력과 같은 경우에 특히 유용하며, 코드의 양을 줄일 수 있다.

---

## 리액트 에서 상태(state)와 속성(props)의 차이

> `상태(state)는 컴포넌트 내부에서 동작 및 렌더링과 같은 부분을 제어하는 데이터`이며, `속성(props)은 부모 컴포넌트로부터 전달 받는 데이터`(반대는 불가, 리액트는 단방향 데이터 흐름) 이다. 상태는 컴포넌트 내에서 변경될 수 있지만, `속성은 읽기 전용(read-only)`이다.

---

## React의 LifeCycle

> 리액트의 생명주기는 크게 마운팅, 업데이트, 언마운팅의 세 단계로 나눌 수 있습니다.

1. 마운팅(`Mounting`)
   - `컴포넌트가 DOM에 삽입될 때 실행됩니다.`
   - 'componentDidMount()' 에서는 네트워크 요청, DOM조작, 이벤트 리스너 설정 등을 수행할 수 있습니다.
2. 업데이트(`Updating`)
   - `컴포넌트의 상태(State)나 속성(Props)이 변경될 때 발생한다.`
   - 'shouldComponentUpdate()' 를 사용하여 불필요한 업데이트를 방지할 수 있습니다.
   - 'componentDidUpdate()' 에서는 업데이트 후의 작업을 수행할 수 있습니다.
3. 언마운팅(`Unmounting`)
   - `컴포넌트가 DOM에서 제거될 때 실행됩니다.`
   - 'componentWillUnmount()' 에서는 이벤트 리스너 제거, 타이머 해제 등의 정리 작업을 수행합니다.

### 함수형 컴포넌트에서 라이프 사이클 메소드를 사용하는 방법

```javascript
// mount
useEffect(() => {
  '페이지 마운트 되거나 업데이트 된 이후 실행 명령어';
}, []);

// unmount
useEffect(() => {
  return () => {
    '업데이트가 되기 전이나 언마운트 되기 전 실행 명령어';
  };
}, []);

// update
hooks(() => {}, ['배열 내 변수가 업데이트 되면 Hooks가 실행']);
```

---

## 리액트의 렌더링 동작 방식

`Trigger -> Render -> Commit`

1. `Trigger` 단계: 컴포넌트 자신 혹은 부모 컴포넌트의 상태(State)나 속성(Props)이 변경된다면, 해당 컴포넌트는 렌더링이 필요하다는 신호를 받습니다. (`렌더링이 필요하다는 신호 감지`)
2. `Render 단계`: Trigger된 컴포넌트 업데이트가 필요한 부분을 가상 DOM에 적용한다. (`렌더링 할 부분 계산`)
3. `Commit` 단계: 가상 DOM에 적용된 변경 사할만 실제 DOM에 적용하여 UI를 업데이트 합니다. (`실제 DOM에 렌더링`)

---

## Dom과 Virtual Dom의 차이점은?

> `DOM의 변경은 비용이 많이 들고` 성능에 영향을 미칠 수 있지만, `가상 DOM은 메모리 내에서 작동하기 때문에 빠르고 효율적`입니다. 또한 실제 `DOM은 직접적으로 업데이트` 되지만, `가상 DOM은 상태 변경 후` 전체 UI를 빠르게 렌더링하고 실제 DOM과의 차이를 계산하여 `필요한 부분만 업데이트` 합니다.

- 가상 DOM을 이용하지 않으면
  > 변화가 있을 때마다 DOM 조작이 일어나고 이에 대한 연산이 수행되며 렌더링되기 때문에 변화를 적용할 때 뜨는 비용이 비교적 크다.
- 가상 DOM을 이용하면
  > 일종의 '오프라인'DOM트리(렌더링 되지 않는다.) 에 변화들을 적용한 뒤 그 변화를 하나로 묶어서 한번에 실제 DOM에 전달하기 때문에 연산 횟수가 줄어들고 변화에 대한 비용이 비교적 작다.

1. DOM(Document Object Model)
   - DOM은 HTML 및 XML 문서의 프로그래밍 인터페이스 이다. 웹 페이지의 구조를 나타내며, javascript를 통해 변경할 수 있습니다.
   - DOM 조작은 비용이 많이 들며, 성능에 영향을 줄 수 있습니다. 특히, 대규모 DOM 업데이트는 웹 페이지의 렌더링 성능을 저하시킬 수 있습니다.
2. 가상 DOM(Virtual DOM)
   - 가상DOM은 실제 DOM을 추상화 한것으로, 메모리에 존재하는 가벼운 DOM 복사본 입니다.
   - 리액트와 같은 일부 Javascript 라이브러리에서 사용되며, UI의 상태를 효율적으로 업데이트 하기 위한 목적으로 설계되었습니다.
   - 상태 변경 시, 리액트는 먼저 가상 DOM에 이 변경사항을 적용한 후, 변경된 가상 DOM과 실제 DOM을 비교합니다. 그리고 실제 DOM에 필요한 최소한의 변경사항만을 적용합니다.

---

## 리액트에서 리스트를 렌더링할 때 '키'의 역할

> `키`는 리액트가 리스트의 `각 요소를 식별`하는 데 사용된다. 이를 통해 요소의 추가, 삭제, 재배열시 `성능을 최적화`할 수 있다.

---

## 리액트의 훅을 사용하는 이유와 자주사용하는 훅은 무엇인가

> 리액트의 훅은 함수형 컴포넌트에서 `상태 관리, 생명주기 처리, 컨텍스트 관리` 등 클래스 컴포넌트의 기능을 사용할 수 있게 해주는 강력한 기능이다. 이를 통해 개발자는 함수형 컴포넌트 내에서 `간결하고 명료한 코드`로 상태를 관리하고, `재사용 가능한 로직`을 쉽게 만들 수 있다. 또한, 훅을 사용하면 `성능 최적화`를 위한 방법들을 적용하기 쉬워지고, `컴포넌트의 분리 및 관심사의 분리`가 용이해져 애플리케이션의 유지보수가 더 효과적이게 된다. `훅의 사용은 리액트 개발의 편의성을 높이고, 코드의 가독성과 재사용성을 향상시키는 중요한 역할`을 한다.

- `useState`: 상태관리를 위한 훅, 함수형 컴포넌트에서 상태(State)를 사용할 수 있게 해준다.
- `useEffect`: Side Effects를 다루기 위한 훅이다. 데이터 가져오기, 구독, 수동 DOM 조작 등의 작업을 수행할 때 사용한다.
- `useContext`: 컨텍스트를 사용하기 위한 훅이다. 컴포넌트 트리 안에서 데이터를 전역적으로 공유할 수 있게 한다.
- useReducer: 복잡한 상태 로직을 관리하기 위한 훅이다. 'useState'의 대안으로, 보다 상세한 상태 업데이트 로직을 구현할 수 있다.
- `useCallback`: 메모이제이션된 콜백을 생성하는 훅이다. 특정 함수를 필요할 때만 재생생하도록 하여 성능을 최적화할 수 있다.
- `useMemo`: 메모이제이션된 값을 계산하기 위한 훅이다. 복잡한 계산 결과를 메모리에 저장하고, 필요할 때 재사용함으로써 성능을 향상시킨다.
- `useRef`: 레퍼런스(ref)를 관리하는 훅 이다. DOM요소에 직접 접근하거나, 렌더링 사이에 값이 유지되어야 하는 변수를 다룰 때 사용한다.
- useImperativeHandle: 부모 컴포넌트가 자식 컴포넌트의 인스턴스 값을 직접 조작할 수 있게 하는 훅이다.
- useLayoutEffect: DOM변경 후, 렌더링이 화면에 반영되기 전에 동기적으로 코드를 실행하는 훅이다. 'useEffect'와 유사하지만, 실행 시점이 다르다.
- useDebugValue: 개발자 도구에서 사용자 정의 훅의 내부 상태를 디버깅하기 위해 사용하는 훅이다.

---

## HOC(고차 컴포넌트)

> 고차 컴포넌트(`Higher-Order Component`)는 `다른 컴포넌트를 인수로 받아 새로운 컴포넌트를 반환하는 함수`이다. HOC는 `컴포넌트의 재사용성, 로직의 추상화 및 분리, 상태 관리 등을 용이`하게 하는 데 사용된다. `HOC는 기본 컴포넌트를 수정하지 않고도 추가 기능을 부여`할 수 있어, React에서 유용한 패턴 중 하나이다.

```javascript
import React, { Component } from 'react';

// 고차 컴포넌트 정의
function withDataFetching(WrappedComponent, dataSource) {
  return class extends Component {
    constructor(props) {
      super(props);
      this.state = {
        data: [],
        isLoading: false,
        error: null,
      };
    }

    componentDidMount() {
      this.setState({ isLoading: true });
      fetch(dataSource)
        .then((response) => response.json())
        .then((data) => this.setState({ data, isLoading: false }))
        .catch((error) => this.setState({ error, isLoading: false }));
    }

    render() {
      return (
        <WrappedComponent
          data={this.state.data}
          isLoading={this.state.isLoading}
          error={this.state.error}
          {...this.props}
        />
      );
    }
  };
}

// 예시 컴포넌트
const MyComponent = ({ data, isLoading, error }) => {
  if (isLoading) return <p>로딩 중...</p>;
  if (error) return <p>오류 발생: {error.message}</p>;
  return (
    <ul>
      {data.map((item) => (
        <li key={item.id}>{item.title}</li>
      ))}
    </ul>
  );
};

// HOC를 사용하여 데이터를 가져오는 컴포넌트 생성
const MyComponentWithData = withDataFetching(
  MyComponent,
  'https://example.com/data'
);

export default MyComponentWithData;
```

> 'withDataFetching'은 고차 컴포넌트로서, 데이터를 가져오는 로직을 담고 있다. 해당 HOC는 'Mycomponent'와 같은 다른 컴포넌트에 적용될 수 있으며, 이를 통해 컴포넌트를 구성하는 동시에 데이터 가져오기 기능을 제공한다.

---

[맨 위로](#react-정리)

|

[처음으로](../README.md)
