# 운영체제 정리

- [프로세스 & 스레드](#프로세스--스레드)
- [프로그램의 컴파일 과정](#프로그램의-컴파일-과정)
- [컨텍스트 스위칭](#컨텍스트-스위칭)
- [프로세스의 5가지 상태](#프로세스의-5가지-상태)
- [멀티프로세싱과 멀티스레딩](#멀티프로세싱과-멀티스레딩)
- [데드락](#데드락)
- [선점형 스케줄링과 비선점형 스케줄링의 차이](#선점형-스케줄링과-비선점형-스케줄링의-차이)
- [공유자원 & 경쟁상태 & 임계영역](#공유자원--경쟁상태--임계영역)
- [뮤텍스 & 세마포어](#뮤텍스--세마포어)
- [인터럽트 (Interrupt)](#인터럽트-interrupt)
- [시스템콜](#시스템콜)
- [가상메모리](#가상메모리)
- [페이지 교체 알고리즘](#페이지-교체-알고리즘)
- [캐시](#캐시)

---

## 프로세스 & 스레드

- 프로세스(Process)

  > 컴퓨터의 메모리에 올라와 실행되고 있는 프로그램, task와 같은 의미로 사용

- 스레드(thread)
  > 프로세스 내 작업의 흐름을 지칭

### 프로세스와 스레드의 차이

- 프로세스(Process)

  1.  `독립성`: 프로세스는 운영체제에서 독립적으로 실행되는 프로그램의 인스턴스이다. 각 프로세스는 독립된 메모리 영역(코드, 데이터, 스택, 힙 등)을 가지며, 다른 프로세스와는 별로로 관리된다.
  2.  `자원 사용`: 프로세스는 상대적으로 많은 시스템 자원을 사용한다. 각 프로세스는 별도의 메모리 공간과 시스템 자원을 필요로 한다.
  3.  `통신과 동기화`: 프로세스 간 통신(IPC)은 상대적으로 복작하며, 파이프, 소켓, 공유 메모리 등의 방법을 사용한다.

- 스레드(Thread)
  1.  `경량 프로세스`: 스레드는 프로세스 내에서 실행되는 실행의 흐름으로, 같은 프로세스 내의 스레드들은 메모리와 자원을 공유합니다.
  2.  `자원 사용`: 스레드는 프로세스에 비해 적은 자원을 사용합니다. 스레드 간에는 코드, 데이터, 힙 영역을 공유하며, 각 스레드는 별도의 스택을 가진다.
  3.  `통신과 동기화`: 같은 프로세스 내의 스레드들은 메모리를 공유하기 때문에 통신이 더 간단하고 효율적이다. 그러나 이로 인해 데이터의 일관성과 동기화 문제가 발생할 수 있다.

### 주요 차이점

- 메모리 공간과 자원의 공유: 프로세스 독립된 메모리 공간을 가지지만, 스레드는 메모리를 공유합니다.
- 생성과 관리의 오버헤드: 프로세스의 생성과 관리는 스레드에 비해 더 많은 시스템 자원과 시간을 소모한다.
- 통신과 동기화의 복잡성: 프로세스 간 통신은 복잡하지만, 스레드 간 통신은 상대적으로 간단하다.

---

## 프로그램의 컴파일 과정

1. 전처리
   > 소스코드의 주석제거, #inclue 등 헤더파일을 병합하고 매크로를 치환한다.
2. 컴파일러
   > 오류처리, 코드 최적화 작업을 하여 어셈블리어로 변환한다.
3. 어셈블러
   > 어셈블리어는 목적코드로 변환된다.
4. 링커
   > 프로그램 내 있는 라이브러 함수 등과 결합해 실행파일이 만들어집니다.

---

## 컨텍스트 스위칭

### PCB(Process Control Block)

> PCB는 운영체제에서 관리하는 프로세스에 대한 메타데이터를 저장한 데이터블록이며 커널 스택에 저장되며 각 프로세스가 생성될 때마다 고유의 PCB가 생성이 되고 프로세스가 종료되면 PCB는 제거된다.

### 컨텍스트 스위칭(Context Switching)

> PCB를 기반으로 프로세스의 상태를 저장하고 다시 복원시키는 과정이다. 이는 프로세스 종료 또는 인터럽트에 의해 발생이된다.

---

## 프로세스의 5가지 상태

![Alt text](image.png)

1. 생성 상태
   > 프로세스가 생성되는 단계이다. 이 단계에서 프로세스는 필요한 자원을 할당받고 초기화를 진행하지만, 아직 CPU에서 실행되기 위한 준비 상태는 아닙니다.
2. 준비 상태
   > 프로세스가 CPU에서 실행될 준비가 완료된 상태이다. 이 상태의 프로세스는 CPU 자원을 기다리며 실행을 위한 준비 큐에 위치합니다. 준비 상태의 프로세스는 CPU를 할당 받기만 하면 즉시 실행 상태로 전환될 수 있습니다.
3. 실행 상태
   > 프로세스가 CPU를 할당받아 명령어를 실행하고 있는 상태이다. 이 단계에서 실제로 프로세스가 작업을 수행합니다. 실행 상태의 프로세스는 시간 할당량이 끝나거나 I/O 요청 등으로 인해 대기 상태로 전환될 수 있습니다.
4. 대기 상태
   > 프로세스가 I/O작업이나 특정 이벤트의 완료를 기다리는 상태입니다. 이 상태에서 프로세스는 CPU를 사용하지 않으며, 대기 중인 이벤트나 작업이 완료되면 다시 준비 상태로 돌아갑니다.
5. 완료 상태
   > 프로세스의 실행이 완료되고 시스템에서 제거되는 상태입니다. 이 단계에서 프로세스는 모든 작업을 마치고 메모리 및 할당 받은 자원을 해제한다.

---

## 멀티프로세싱과 멀티스레딩

- 멀티프로세싱

  > 여러 개의 프로세스를 통해 동시에 두 가지 이상의 일을 수행할 수 있는 것을 말한다. 특정 프로세스 중 일부에 문제가 발생되더라도 다른 프로세스에 영향을 미치지 않으며 격리성과 신뢰성이 높은 강점이 있다.

- 멀티스레싱
  > 프로세스 내 작업을 멀티스레드로 처리하는 기법이며 스레드끼리 서로 자원을 공유하고 프로세스보다는 가볍기 때문에 효율성이 높은 장점이 있다. 하지만 한 스레드에 문제가 생기면 다른 스레드에도 영향을 끼쳐 스레드로 이루어져 있는 프로세스에 영향을 줄 수 있다.

### 멀티스레싱의 동시성과 병렬성

- 동시성: 싱글코어에서 여러 개의 쓰레드가 번갈아 가면서 실행
- 병렬성: 멀티 코어에서 한 개 이상의 스레드를 포함하는 각 코어 들이 동시에 실행

### 멀티스레싱 주의사항

> 다수의 스레드가 공유 데이터에 동시에 접근하는 경우에 상호배제 또는 동기화 기법을 통해 동시성 문제 또는 교착상태가 발생하지 않도록 주의해야한다.

---

## 데드락

> 둘 이상의 프로세스들이 자원을 점유한 상태에서 서로 다른 프로세스가 점유하고 있는 자원을 요구하며 무한정 대기 상황

### 조건

- 비선점: 다른 프로세스의 자원을 뺏을 수 없다.
- 순환대기: 두 개 이사의 프로세스가 자원 접근을 기다림
- 점유대기: 공유 자원에 대한 접근 권한을 가진 채로 다른 자원에 대한 접근 권한을 요구
- 상호배제: 한 번에 한 프로세스만 공유 자원에 접근 가능하며, 접근 권한이 제한적일 경우

---

## 선점형 스케줄링과 비선점형 스케줄링의 차이

> 선점형은 하나의 프로세스가 다른 프로세스 대신에 CPU를 차지할 수 있음을 의미, 비선점형은 하나의 프로세스가 끝나지 않으면 다른 프로세스는 CPU를 사용할 수 없다.

- 선점형 스케줄링:
  - 라운드로빈: 각 프로세스는 동일한 할당 시간을 주고 그 시간 알에 끝나지 않으면 다시 준비 큐의 뒤로 가는 알고리즘
  - SRF(Shortest Remaining time First): 중간에 더 짧은 작업이 들어오면 수행하던 프로세스를 중지하고 해당 프로세스를 수행하는 알고리즘
  - 다단계 큐: 우선순위에 따른 준비 큐를 여러 개 사용하고, 큐마다 라운드 로빈이나 FCFS등 다른 스케줄링 알로리즘을 적용한 것
- 비선점형 스케줄링
  - FCFS(First Come First Served): 가장 먼저 온 것을 가장 먼저 처리
  - SJF(Shortest Job First): 실행 시간이 가장 짧은 프로세스를 가장 먼저 실행
  - 우선순위: 오래된 작업일 수록 우선순위를 높이는 방법의 알고리즘

---

## 공유자원 & 경쟁상태 & 임계영역

- 공유 자원
  > 시스템 안에서 각 프로세스, 스레드가 함께 접근할 수 있는 모니터, 프린터, 메모리, 파일, 데이터 등의 자원이나 변수를 의미한다.
- 경쟁 상태
  > 이 공유 자원을 둘 이상의 프로세스 또는 스레드가 동시에 읽거나 쓰는 상황을 말하며 동시에 접근을 시도할 때의 타이밍이 예상되는 결과 값에 영향을 줄 수 있는 상태
- 임계 영역
  > 둘 이상의 프로세스 또는 스레드가 공유자원에 접근할 때 순서 등의 이유로 결과가 달라지는 코드 영역을 말한다. 이 영역은 한 번에 둘 이상의 프로세스나 스레드가 들어갈 수 없게 설계

---

## 뮤텍스 & 세마포어

### 뮤텍스(Mutex)

- 기본개념
  > 뮤텍스는 상호배제의 줄임말로, 한번에 하나의 스레드만 특정 자원 또는 코드 영역에 접근할 수 있도록 하는데 사용된다.
- 용도
  > 공유 자원에 대한 접근을 단일 스레드로 제한하기 위해 사용된다. 이를 통해 데이터의 일관성과 무결성을 유지할 수 있다.
- 특징
  > 뮤텍스는 잠금과 해제의 개념을 사용한다. 한 스레드가 뮤텍스를 잠그면, 다른 스레드는 그 뮤텍스가 해제될 때 까지 기다려야한다.

### 세마포어(Semaphore)

- 기본 개념
  > 특정 자원에 대한 접근을 제한하는 카운팅 기반의 동기화 메커니즘 이다. 세마포어는 내부적으로 카운터를 유지하며, 이 카운터는 동시에 접근할 수 있는 스레드의 최대 수를 결정한다.
- 용도
  > 여러 스레드가 동시에 리소스에 접근할 수 있도록 하는 데 사용된다. 예를 들어 데이터베이스 연결 풀에 대한 동시 접근 제한에 사용될 수 있다.
- 특징
  > 세마포어는 시그널과 웨이트 연산으로 작동한다. 세마포어의 값이 0이면 대기 상태에 머무르고, 0보다 크면 해당 스레드는 자원에 접근할 수 있다.

### 뮤텍스와 세마포어의 차이점

- 소유권
  > 뮤텍스는 잠금을 소유하는 개념이 있다. 즉, 뮤텍스를 잠그는 스레드가 반드시 해제해야 한다. 세마포어는 소유권 개념이 없다.
- 스레드 수
  > 뮤텍스는 한 번에 하나의 스레드만 접근을 허용하는 반면, 세마포어는 지정된 수의 여러 스레드가 동시에 접근할 수 있다.
- 사용 목적
  > 뮤텍스는 상호 배제를 위해 사용되며, 세마포어는 제한된 수의 자원을 여러 스레드 간에 조율하기 위해 사용된다.

---

## 인터럽트 (Interrupt)

> 인터럽트는 어떤 신호가 들어왔을 때 CPU를 잠깐 정지 시키는것을 말한다.

- 하드웨어 인터럽트
  > IO 디바이스 와 같은 하드웨어에서 발생하는 인터럽트이다.
- 소프트웨어 입터럽트
  > 트랩이라고도 하며, 프로세스 오류, 종료, 시작 등을 기반으로 프로세스에서 발생하는 인터럽트이며 우선순위가 하드웨어 인터럽트보다 높다.

---

## 시스템콜

> 시스템 콜이란 운영체제가 `커널에 접근하기 위한 인터페이스`로 유저 프로그램이 운영체제의 서비스를 받기 위해 커널함수를 호출할 때 이를 거쳐서 호출하도록 설계되어있다.

### 시스템 콜의 과정

> I/O 요청을 위한 트랩을 발동시

1. 유저 프로그램이 I/O 요청 트랩발동합니다.
2. 올바른 I/O 요청인지 확인합니다.
3. 유저 모드가 시스템콜을 통해 커널모드로 변환합니다.
4. 이후 커널함수를 실행합니다.

### 시스템 콜의 장점은?

> 유저 프로그램은 시스템콜을 기반으로 커널과 분리된다. 즉, 유저프로그램은 복답한 파일 시스템과 프로세스 생성 등에 대한 내부 동작을 신경쓸 필요가 없다. 또한, 운영체제의 관리하에 프로그램이 운영되므로 시스템의 안정성과 보안이 강화된다.

---

## 가상메모리

> 가상메모리는 OS에서 사용되는 메모리 관리 기법의 하나로 컴퓨터가 실제로 이용가능한 메모리 자원을 추상화하여 이를 사용하는 사용자들에게 매우 큰 메로리로 보이게 만드는 것

### 가상 메모리의 필요성

> 필요한 데이터만 램에 올리고 다시 사용하지 않으면 하드디스크로 내림으로써 `주기억장치의 효율적 관리(스와핑)`하게 된다. 각 프로세스마다 통일된 주소 공간을 배정할 수 있어 `메모리 관리가 단순`해지고, `메모리 용량 및 안정성이 보장`된다.

---

## 페이지 교체 알고리즘

- FIFO(First In First Out)
  > 가장 먼저 온 페이지부터 교체하는 방법
- LRU(Least Recently Used)
  > 최근에 사용되지 않은 페이지를 바꾸는 방법으로 참조가 오래된 페이지를 바꾼다. 해당 교체를 위해 각 페이지마다 최근 사용한 횟수를 나타내는 자료구조가 필요할 수 있다.
- NUR(Not Used recently)
  > `clock 알고리즘`이라 하며 1은 최근 참조, 0은 참조되지 않음을 의미한다. 만약 한 싸이클 도는 동안 사용되지 않으면 0이되고, 한 방향으로 돌면서 0을 찾고 0을 찾은 순간 해당 페이지를 교체하고, 해당 부분을 1로 바꾸는 알고리즘 이다.
- LFU(Least Frequently Used)
  > 가장 참조 횟수가 적은 페이지를 교체하는 알고리즘이다.

---

## 캐시

> 데이터를 미리 복사해 놓는 임시 저장소이자 빠른 장치와 느린 장치에서 속도 차이에 따른 병목 현상을 줄이기 위한 메모리이다.

- 시간 지역성: 시간 지역성은 최근 사용한 데이터에 다시 접근하려는 특성
- 공간 지역성: 공간 지역성은 최근 접근한 데이터를 이루고 있는 공간이나 그 가까운 공간에 접근하는 특성

[맨 위로](#운영체제-정리)

|

[처음으로](../README.md)
